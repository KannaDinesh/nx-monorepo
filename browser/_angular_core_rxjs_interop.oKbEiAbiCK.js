var O=Object.defineProperty,R=Object.defineProperties;var q=Object.getOwnPropertyDescriptors;var g=Object.getOwnPropertySymbols;var C=Object.prototype.hasOwnProperty,M=Object.prototype.propertyIsEnumerable;var m=(n,e,t)=>e in n?O(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t,w=(n,e)=>{for(var t in e||={})C.call(e,t)&&m(n,t,e[t]);if(g)for(var t of g(e))M.call(e,t)&&m(n,t,e[t]);return n},h=(n,e)=>R(n,q(e));import{assertInInjectionContext as a,inject as l,DestroyRef as i,\u0275RuntimeError as f,\u0275getOutputDestroyRef as I,Injector as y,effect as E,untracked as d,\u0275microtaskEffect as T,signal as k,computed as U,PendingTasks as F,resource as N}from"@angular/core";import{Observable as p,ReplaySubject as x,Subject as P}from"rxjs";import{takeUntil as j,take as L}from"rxjs/operators";function D(n){n||(a(D),n=l(i));let e=new p(t=>n.onDestroy(t.next.bind(t)));return t=>t.pipe(j(e))}var v=class{source;destroyed=!1;destroyRef=l(i);constructor(e){this.source=e,this.destroyRef.onDestroy(()=>{this.destroyed=!0})}subscribe(e){if(this.destroyed)throw new f(953,!1);let t=this.source.pipe(D(this.destroyRef)).subscribe({next:r=>e(r)});return{unsubscribe:()=>t.unsubscribe()}}};function Q(n,e){return new v(n)}function W(n){let e=I(n);return new p(t=>{e?.onDestroy(()=>t.complete());let r=n.subscribe(s=>t.next(s));return()=>r.unsubscribe()})}function S(n,e){!e?.injector&&a(S);let t=e?.injector??l(y),r=new x(1),s=E(()=>{let o;try{o=n()}catch(u){d(()=>r.error(u));return}d(()=>r.next(o))},{injector:t,manualCleanup:!0});return t.get(i).onDestroy(()=>{s.destroy(),r.complete()}),r.asObservable()}function X(n,e){!e?.injector&&a(S);let t=e?.injector??l(y),r=new x(1),s=T(()=>{let o;try{o=n()}catch(u){d(()=>r.error(u));return}d(()=>r.next(o))},{injector:t,manualCleanup:!0});return t.get(i).onDestroy(()=>{s.destroy(),r.complete()}),r.asObservable()}function V(n,e){let t=!e?.manualCleanup;t&&!e?.injector&&a(V);let r=t?e?.injector?.get(i)??l(i):null,s=$(e?.equal),o;e?.requireSync?o=k({kind:0},{equal:s}):o=k({kind:1,value:e?.initialValue},{equal:s});let u=n.subscribe({next:c=>o.set({kind:1,value:c}),error:c=>{if(e?.rejectErrors)throw c;o.set({kind:2,error:c})}});if(e?.requireSync&&o().kind===0)throw new f(601,!1);return r?.onDestroy(u.unsubscribe.bind(u)),U(()=>{let c=o();switch(c.kind){case 1:return c.value;case 2:throw c.error;case 0:throw new f(601,!1)}},{equal:e?.equal})}function $(n=Object.is){return(e,t)=>e.kind===1&&t.kind===1&&n(e.value,t.value)}function z(n){n===void 0&&(a(z),n=l(y));let e=n.get(F);return t=>new p(r=>{let s=e.add(),o=!1;function u(){o||(s(),o=!0)}let c=t.subscribe({next:b=>{r.next(b),u()},complete:()=>{r.complete(),u()},error:b=>{r.error(b),u()}});return c.add(()=>{r.unsubscribe(),u()}),c})}function A(n){return n?.injector||a(A),N(h(w({},n),{loader:e=>{let t=new P;return e.abortSignal.addEventListener("abort",()=>t.next()),new Promise((r,s)=>{n.loader(e).pipe(L(1),j(t)).subscribe({next:r,error:s,complete:()=>s(new Error("Resource completed before producing a value"))})})}}))}export{Q as outputFromObservable,W as outputToObservable,z as pendingUntilEvent,A as rxResource,D as takeUntilDestroyed,S as toObservable,V as toSignal,X as \u0275toObservableMicrotask};
/*! Bundled license information:

@angular/core/fesm2022/rxjs-interop.mjs:
  (**
   * @license Angular v19.1.7
   * (c) 2010-2024 Google LLC. https://angular.io/
   * License: MIT
   *)
*/
